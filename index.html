<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Platformer Playlist Creator</title>
    <style>
        :root {
            --primary-color: #4CAF50;
            --dark-bg: #1a1a1a;
            --medium-bg: #2a2a2a;
            --dark-border: #555;
            --text-color: #f0f0f0;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0; padding: 0; background-color: var(--dark-bg); color: var(--text-color);
            display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; overflow: hidden;
        }
        canvas {
            background-color: #0d0d0d; border: 2px solid var(--dark-border); cursor: crosshair;
        }
        .screen {
            display: none; flex-direction: column; align-items: center; justify-content: center; width: 100%; height: 100%;
        }
        .screen.active { display: flex; }
        h1, h2 { color: var(--primary-color); text-shadow: 2px 2px #000; }
        button, input {
            padding: 12px 20px; margin: 8px; border: none; border-radius: 5px; font-size: 16px; cursor: pointer;
            background-color: var(--primary-color); color: white; transition: background-color 0.3s;
        }
        button:hover { background-color: #45a049; }
        input[type="text"] {
            width: 90%; background-color: #333; border: 2px solid var(--dark-border);
        }
        #editor-container { display: flex; gap: 20px; align-items: flex-start; }
        #playlist-controls { background-color: var(--medium-bg); padding: 15px; border-radius: 8px; width: 250px; text-align: center; }
        #playlist-levels-list { list-style-type: none; padding: 0; max-height: 200px; overflow-y: auto; text-align: left;}
        #playlist-levels-list li {
            padding: 10px; margin-bottom: 5px; background: #333; border-radius: 4px; cursor: pointer;
            border-left: 4px solid transparent;
        }
        #playlist-levels-list li.selected { border-left-color: var(--primary-color); background: #444; }
        #editor-ui { display: flex; flex-wrap: wrap; justify-content: center; margin-top: 15px; }
        #editor-ui .tool { padding: 10px; margin: 5px; border: 2px solid var(--dark-border); border-radius: 5px; cursor: pointer; }
        #editor-ui .tool.selected { background-color: var(--primary-color); border-color: #fff; }
        #key-output { margin-top: 15px; width: 80%; max-width: 800px; padding: 10px; background: #222; border: 1px solid #444; word-wrap: break-word; min-height: 20px; font-family: 'Courier New', monospace; }
        #level-selector-grid { display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; }
    </style>
</head>
<body>

    <div id="main-menu" class="screen active">
        <h1>Platformer Playlist Creator</h1>
        <button onclick="startNewPlaylist()">Create New Playlist</button>
        <input type="text" id="key-input" placeholder="Paste Level or Playlist Key...">
        <button onclick="loadKeyFromInput()">Play</button>
    </div>

    <div id="editor-screen" class="screen">
        <div id="editor-container">
            <div id="playlist-controls">
                <h2>Playlist Editor</h2>
                <input type="text" id="playlist-name" placeholder="Playlist Name" onchange="updatePlaylistName()">
                <ul id="playlist-levels-list"></ul>
                <button onclick="addNewLevel()">Add New Level</button>
                <button onclick="deleteSelectedLevel()">Delete Selected</button>
                
                <hr style="border-color: var(--dark-border); margin: 20px 0;">
                <input type="text" id="playlist-key-importer" placeholder="Paste Playlist Key...">
                <button onclick="importPlaylistToEditor()">Load Key to Editor</button>

            </div>
            <div>
                <canvas id="editor-canvas" width="800" height="480"></canvas>
                <div id="editor-ui">
                    <span>Tools:</span>
                    <div class="tool selected" id="tool-wall" onclick="selectTool('wall')">üß± Wall</div>
                    <div class="tool" id="tool-player" onclick="selectTool('player')">üë§ Player</div>
                    <div class="tool" id="tool-goal" onclick="selectTool('goal')">üèÜ Goal</div>
                    <div class="tool" id="tool-erase" onclick="selectTool('erase')">‚ùå Erase</div>
                </div>
            </div>
        </div>
        <button onclick="exportPlaylistKey()">Export Playlist Key</button>
        <button onclick="showScreen('main-menu')">Back to Menu</button>
        <div id="key-output"></div>
    </div>

    <div id="level-selector-screen" class="screen">
        <h1 id="playlist-title"></h1>
        <div id="level-selector-grid"></div>
        <button onclick="showScreen('main-menu')">Back to Menu</button>
    </div>

    <div id="game-screen" class="screen">
        <h2 id="game-level-title"></h2>
        <canvas id="game-canvas" width="800" height="480"></canvas>
        <p>Use Arrow Keys or WASD to move. Hold jump for more height. Reach the trophy! üèÜ</p>
        <button onclick="showScreen('level-selector-screen')">Back to Level Select</button>
    </div>

    <script>
    // --- CONFIG ---
    // ‚ú® Grid size is now smaller for more detail. Physics values are scaled to match.
    const GRID_SIZE = 20;
    const GRAVITY = 0.25;
    const JUMP_FORCE = -6;
    const MOVE_SPEED = 2.5;

    // --- DOM ELEMENTS ---
    const editorCanvas = document.getElementById('editor-canvas'), editorCtx = editorCanvas.getContext('2d');
    const gameCanvas = document.getElementById('game-canvas'), gameCtx = gameCanvas.getContext('2d');
    const keyOutput = document.getElementById('key-output');

    // --- STATE ---
    let currentScreen = 'main-menu', selectedTool = 'wall', isPainting = false;
    const keys = {};
    
    // Editor State
    let editorPlaylist = { name: "Untitled Playlist", levels: [] };
    let currentEditingLevelIndex = -1;

    // Game State
    let player = { x: 0, y: 0, width: GRID_SIZE * 0.8, height: GRID_SIZE * 0.8, vx: 0, vy: 0, onGround: false };
    let gameObjects = [], gameGoalPos = {}, gamePlayerStart = {};
    let currentPlaylist = { name: "", levels: [] };
    let currentLevelIndex = -1;

    // --- SCREEN NAVIGATION ---
    function showScreen(screenId) {
        document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
        document.getElementById(screenId).classList.add('active');
        currentScreen = screenId;
    }

    // --- EDITOR LOGIC ---
    function startNewPlaylist() {
        editorPlaylist = { name: "Untitled Playlist", levels: [{ p: [-1,-1], g: [-1,-1], w: [] }] };
        document.getElementById('playlist-name').value = editorPlaylist.name;
        selectLevelForEditing(0);
        showScreen('editor-screen');
    }
    
    function updatePlaylistName() {
        editorPlaylist.name = document.getElementById('playlist-name').value || "Untitled Playlist";
    }

    function selectLevelForEditing(index) {
        if (index < 0 || index >= editorPlaylist.levels.length) {
            currentEditingLevelIndex = -1;
            drawEditor(); // Clear canvas
            return;
        }
        currentEditingLevelIndex = index;
        drawEditor(); // Redraw with the new level's data
        updateLevelListUI();
    }

    function addNewLevel() {
        editorPlaylist.levels.push({ p: [-1, -1], g: [-1, -1], w: [] });
        selectLevelForEditing(editorPlaylist.levels.length - 1);
    }
    
    function deleteSelectedLevel() {
        if (currentEditingLevelIndex < 0) return;
        editorPlaylist.levels.splice(currentEditingLevelIndex, 1);
        if (editorPlaylist.levels.length === 0) {
            currentEditingLevelIndex = -1;
            drawEditor(); // Clear canvas
        } else {
            selectLevelForEditing(Math.max(0, currentEditingLevelIndex - 1));
        }
        updateLevelListUI();
    }
    
    function updateLevelListUI() {
        const list = document.getElementById('playlist-levels-list');
        list.innerHTML = '';
        editorPlaylist.levels.forEach((level, index) => {
            const li = document.createElement('li');
            li.textContent = `Level ${index + 1}`;
            if (index === currentEditingLevelIndex) li.classList.add('selected');
            li.onclick = () => selectLevelForEditing(index);
            list.appendChild(li);
        });
    }

    function selectTool(tool) {
        document.querySelectorAll('.tool').forEach(t => t.classList.remove('selected'));
        document.getElementById(`tool-${tool}`).classList.add('selected');
        selectedTool = tool;
    }

    function drawEditor() {
        editorCtx.clearRect(0, 0, editorCanvas.width, editorCanvas.height);
        // Draw Grid
        editorCtx.strokeStyle = '#404040'; editorCtx.lineWidth = 0.5;
        for (let x = 0; x < editorCanvas.width; x += GRID_SIZE) { editorCtx.beginPath(); editorCtx.moveTo(x, 0); editorCtx.lineTo(x, editorCanvas.height); editorCtx.stroke(); }
        for (let y = 0; y < editorCanvas.height; y += GRID_SIZE) { editorCtx.beginPath(); editorCtx.moveTo(0, y); editorCtx.lineTo(editorCanvas.width, y); editorCtx.stroke(); }
        editorCtx.lineWidth = 1;

        // Draw Objects from current level
        if (currentEditingLevelIndex < 0) return;
        const level = editorPlaylist.levels[currentEditingLevelIndex];
        editorCtx.fillStyle = '#8B4513';
        level.w.forEach(pos => editorCtx.fillRect(pos[0] * GRID_SIZE, pos[1] * GRID_SIZE, GRID_SIZE, GRID_SIZE));
        
        if (level.p[0] !== -1) {
            editorCtx.fillStyle = 'rgba(0, 150, 255, 0.8)';
            editorCtx.fillRect(level.p[0] * GRID_SIZE, level.p[1] * GRID_SIZE, GRID_SIZE, GRID_SIZE);
        }
        if (level.g[0] !== -1) {
            editorCtx.font = `${GRID_SIZE}px sans-serif`;
            editorCtx.fillText('üèÜ', level.g[0] * GRID_SIZE, level.g[1] * GRID_SIZE + GRID_SIZE - 5);
        }
    }

    function handleEditorAction(event) {
        if (currentEditingLevelIndex < 0) return;
        const rect = editorCanvas.getBoundingClientRect();
        const gridX = Math.floor((event.clientX - rect.left) / GRID_SIZE);
        const gridY = Math.floor((event.clientY - rect.top) / GRID_SIZE);
        if (gridX < 0 || gridX >= editorCanvas.width / GRID_SIZE || gridY < 0 || gridY >= editorCanvas.height / GRID_SIZE) return;

        const level = editorPlaylist.levels[currentEditingLevelIndex];

        const clearSpot = () => {
            level.w = level.w.filter(pos => pos[0] !== gridX || pos[1] !== gridY);
            if(level.p[0] === gridX && level.p[1] === gridY) level.p = [-1,-1];
            if(level.g[0] === gridX && level.g[1] === gridY) level.g = [-1,-1];
        }

        if (selectedTool === 'erase') {
            clearSpot();
        } else if (selectedTool === 'wall') {
            clearSpot();
            level.w.push([gridX, gridY]);
        } else if (selectedTool === 'player') {
            clearSpot();
            level.p = [gridX, gridY];
        } else if (selectedTool === 'goal') {
            clearSpot();
            level.g = [gridX, gridY];
        }
        drawEditor();
    }
    editorCanvas.addEventListener('mousedown', (e) => { isPainting = true; handleEditorAction(e); });
    editorCanvas.addEventListener('mousemove', (e) => { if (isPainting) handleEditorAction(e); });
    window.addEventListener('mouseup', () => isPainting = false);
    editorCanvas.addEventListener('mouseleave', () => isPainting = false);

    // --- KEY IMPORT / EXPORT ---
    function importPlaylistToEditor() {
        const keyInput = document.getElementById('playlist-key-importer');
        const key = keyInput.value.trim();
        if (!key) {
            alert("Please paste a key into the 'Code' box first.");
            return;
        }
        try {
            const decoded = JSON.parse(atob(key));
            if (decoded.type !== 'playlist' || !Array.isArray(decoded.data)) {
                throw new Error("Invalid key type. Only Playlist Keys can be loaded here.");
            }
            editorPlaylist = { name: decoded.name, levels: decoded.data };
            
            document.getElementById('playlist-name').value = editorPlaylist.name;
            selectLevelForEditing(0);
            
            keyInput.value = '';
            alert(`Playlist '${editorPlaylist.name}' loaded successfully!`);
        } catch (e) {
            alert("Invalid Playlist Key. Please check the code and try again.");
            console.error(e);
        }
    }

    function exportPlaylistKey() {
        for(let i = 0; i < editorPlaylist.levels.length; i++) {
            const level = editorPlaylist.levels[i];
            if (level.p[0] === -1 || level.g[0] === -1) {
                alert(`Level ${i + 1} is incomplete! It needs a Player Start and a Goal.`);
                return;
            }
        }
        const finalObject = { type: "playlist", name: editorPlaylist.name, data: editorPlaylist.levels };
        keyOutput.textContent = btoa(JSON.stringify(finalObject));
    }

    function loadKeyFromInput() {
        try {
            const key = document.getElementById('key-input').value.trim();
            const decoded = JSON.parse(atob(key));
            
            if (decoded.type === 'playlist') {
                currentPlaylist = { name: decoded.name, levels: decoded.data };
                displayLevelSelector();
            } else {
                currentPlaylist = { name: "Single Level", levels: [decoded] };
                startLevel(0);
            }
        } catch (e) {
            alert("Invalid key!");
            console.error(e);
        }
    }
    
    // --- LEVEL SELECTOR & GAME FLOW ---
    function displayLevelSelector() {
        const grid = document.getElementById('level-selector-grid');
        document.getElementById('playlist-title').textContent = currentPlaylist.name;
        grid.innerHTML = '';
        currentPlaylist.levels.forEach((level, index) => {
            const button = document.createElement('button');
            button.textContent = `Level ${index + 1}`;
            button.onclick = () => startLevel(index);
            grid.appendChild(button);
        });
        showScreen('level-selector-screen');
    }

    function startLevel(index) {
        currentLevelIndex = index;
        const levelData = currentPlaylist.levels[index];
        
        gamePlayerStart = { x: levelData.p[0] * GRID_SIZE, y: levelData.p[1] * GRID_SIZE };
        gameGoalPos = { x: levelData.g[0] * GRID_SIZE, y: levelData.g[1] * GRID_SIZE };
        gameObjects = levelData.w.map(pos => ({ x: pos[0] * GRID_SIZE, y: pos[1] * GRID_SIZE }));
        
        document.getElementById('game-level-title').textContent = `${currentPlaylist.name} - Level ${index + 1}`;
        resetGame();
        showScreen('game-screen');
        gameLoop();
    }

    function onLevelComplete() {
        currentLevelIndex++;
        if (currentLevelIndex < currentPlaylist.levels.length) {
            startLevel(currentLevelIndex);
        } else {
            alert(`üéâ Playlist Complete! You beat ${currentPlaylist.name}! üéâ`);
            displayLevelSelector();
        }
    }

    // --- GAME LOGIC ---
    function resetGame() {
        player.x = gamePlayerStart.x + (GRID_SIZE - player.width) / 2;
        player.y = gamePlayerStart.y + (GRID_SIZE - player.height) / 2;
        player.vx = 0; player.vy = 0; player.onGround = false;
    }

    function updateGame() {
        player.vx = 0;
        if (keys['ArrowLeft'] || keys['a']) player.vx = -MOVE_SPEED;
        if (keys['ArrowRight'] || keys['d']) player.vx = MOVE_SPEED;
        if ((keys['ArrowUp'] || keys['w'] || keys[' ']) && player.onGround) { player.vy = JUMP_FORCE; player.onGround = false; }
        player.vy += GRAVITY;

        player.x += player.vx;
        for (const wall of gameObjects) {
            if (player.x < wall.x + GRID_SIZE && player.x + player.width > wall.x && player.y < wall.y + GRID_SIZE && player.y + player.height > wall.y) {
                if (player.vx > 0) player.x = wall.x - player.width;
                if (player.vx < 0) player.x = wall.x + GRID_SIZE;
            }
        }
        player.y += player.vy;
        player.onGround = false;
        for (const wall of gameObjects) {
            if (player.x < wall.x + GRID_SIZE && player.x + player.width > wall.x && player.y < wall.y + GRID_SIZE && player.y + player.height > wall.y) {
                if (player.vy > 0) { player.y = wall.y - player.height; player.onGround = true; player.vy = 0; }
                if (player.vy < 0) { player.y = wall.y + GRID_SIZE; player.vy = 0; }
            }
        }
        if (player.x < gameGoalPos.x + GRID_SIZE && player.x + player.width > gameGoalPos.x && player.y < gameGoalPos.y + GRID_SIZE && player.y + player.height > gameGoalPos.y) {
            onLevelComplete();
        }
        if (player.y > gameCanvas.height) resetGame();
    }

    function drawGame() {
        gameCtx.clearRect(0, 0, gameCanvas.width, gameCanvas.height);
        gameCtx.fillStyle = '#8B4513';
        gameObjects.forEach(obj => gameCtx.fillRect(obj.x, obj.y, GRID_SIZE, GRID_SIZE));
        gameCtx.font = `${GRID_SIZE}px sans-serif`;
        gameCtx.fillText('üèÜ', gameGoalPos.x, gameGoalPos.y + GRID_SIZE - 5);
        gameCtx.fillStyle = '#0096FF';
        gameCtx.fillRect(player.x, player.y, player.width, player.height);
    }
    
    let animationFrameId;
    function gameLoop() {
        if (currentScreen !== 'game-screen') {
            cancelAnimationFrame(animationFrameId);
            return;
        }
        updateGame();
        drawGame();
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    
    // --- EVENT LISTENERS ---
    window.addEventListener('keydown', (e) => keys[e.key] = true);
    window.addEventListener('keyup', (e) => {
        keys[e.key] = false;
        if ((e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') && player.vy < 0) { player.vy *= 0.5; }
    });
    window.addEventListener('blur', () => { for (const key in keys) { keys[key] = false; } });
    
    // --- INITIAL LOAD ---
    showScreen('main-menu');
    </script>
</body>
</html>
